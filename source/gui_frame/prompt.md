# ChatGPTに作業させるためのプロンプト

作業は以下の手順で行う。
+ 試作のプログラムを書く
+ テストコードを書く
+ テスト結果で問題があれば、chatGPTに修正してもらう
+ 正常動作したらクラスの仕様書を書く

この手順で実施することで、品質の高いソースコードを出力することができる。
クラス単独で機能を完結できるようにし、最終的にmainのループの中から呼び出すか、スレッドで起動できる形で実装する。


## クラスの仕様を書いてもらう

試作のソースコードを元に、クラス図を書いてもらうプロンプト。

---
xxxクラスの機能を表した詳細な仕様を説明してください。
仕様を読んだプログラマがpythonで実装できるように書いてください。
マークダウンでお願いします。

関数一覧は、以下のように整えてください。

#### 初期化関数 `__init__(self, )`
- 引数：
- 機能：

また、クラス図をplantumlで詳細に書いて実装に役立てることができるようにしてください。
以下、ソースコードです。

(以下、ソースを貼り付ける)

---

### スレッドで動かし、スレッド間でデータを共有する
スレッドを使用する場合は、以下のプロンプトを追加します。

---

このクラスはスレッドで起動できるようにします。

#### 実装例(objectというクラスを使用する場合)
スレッドセーフなデータ共有クラスSharedDataのインスタンスをインポートして初期化し、スレッド間で共有するデータがあるなら利用します。
(必要であればSharedDataクラスの実装をコピーします)

mainから以下のように初期化して実行を開始する想定でクラスを実装します。

```
    object_manager = object(shared_data)
    object_thread = threading.Thread(target=object_manager.run)
    object_thread.start()
    object_thread.join()
```

---

### mainループで動かすtkinterのGUIで、スレッド間でデータを共有する
tkinterでGUIを実装する場合、スレッドで動かすことが奨励されないため、サンプルのように実装します。
スレッドセーフなデータ共有クラスSharedDataのインスタンスをインポートして初期化し、スレッド間で共有するデータがあるなら利用します。
(必要であればSharedDataクラスの実装をコピーします)

mainから以下のように初期化して実行を開始する想定でクラスを実装します。
```
    object_manager = object(shared_data)
    object_thread.run()
```

このクラスの初期化や実行、コールバックの実装例です。
```
import tkinter as tk

class GuiManager(tk.Tk):
    def __init__(self, shared_data):
        super().__init__()
        self.title("GUI Manager")

    def _on_slider_change(self, value):
        self.shared_data.set_value("speed", float(value))

    def run(self):
        super().mainloop() # Change this line
```

### ディレクトリ構造を整えて、ライブラリの構成を初期化する

main.pyから、leg_simulationディレクトリのすべてのライブラリを呼び出すことができるように、__init__.pyを作ってください。
また、gui_frameディレクトリのライブラリも呼び出せるように__init__.pyを設定してください。

ディレクトリ構成は以下のようになっています。

source/
├── main.py
├── leg_simulation/
│   ├── leg.py
│   ├── linkage4bar.py
│   ├── linkage5bar.py
│   └── robot.py
│
├── gui_frame/
│   ├── GraphGui.py
│   ├── opengl_manager.py
│   ├── pygame_manager.py
│   └── shared_data.py


-------
課題1

脚の座標系はOKだが、ロボットの座標系はどのように決定したらよいか？
ロボットの未確定の座標系を中心に、脚の座標が伸びている。
仮に脚が両方とも地面と接しているとして、ロボットの座標系を計算する。それを初期値として設定する。
-------
プロンプト 座標系設計

以下の座標系を設計し、Pythonで実行します。
座標系を管理する適切なライブラリや、ソフトウェアの構造を提案してください。

**要求**
3次元の座標系を想定してください。
不変のWorld座標系があり、その下にRobotクラスの座標系が存在します。
RobotクラスはLegクラスのインスタンスを2つ持ちます。
Robotクラスの座標系の下にLegがあるので、Robotクラスの座標系によって、Legの座標系は影響を受けます。

World座標系には床があり、原点(0,0,0)を中心に、Z = 0の平面です。
このプロジェクトのすべての頂点は、負の座標方向には通り抜けができないように接触判定を受けます。
Legクラスのメンバーの頂点は、床を通り抜けることができず、Z軸の正の方向にしか存在できません。

RobotクラスはLegクラスが受ける接触判定に影響され、その影響がRobotクラスの座標系に及びます。
また、Robotクラスが受けた座標系の影響が、Legクラスに影響を与えます。

これら、接触判定と座標系の影響を検証できるソフトウェアの構造を設計してください。

-------
上のプロンプトを元に調整して基本のプログラムを作成して表示ができるようになったので、仕様を整理させる。
-------



-------
課題2

USBを経由してシリアル通信を行い、シリアルサーボと通信する。
このプログラムと同じ動きをハードウェアがするかどうかを比較、検証します。

-------
作ったプログラムを説明させるプロンプト

このプログラムの詳細な仕様を説明してください。
仕様を読んだプログラマがpythonで実装できるように書いてください。
マークダウンでお願いします。

以下、ソースコードです。

(以下、ソースを貼り付ける)

------


このプログラムは、3次元空間内でロボットとその脚を表現し、ロボットの移動と衝突検出、および3Dグラフ上での可視化を行います。

**要求**
不変のWorld座標系に対して、ロボットの座標系を回転と平行移動できる構造とする。
Legクラスのvertex2をエンドエフェクタとも呼ぶ。
2つのエンドエフェクタを結んだ線Aと、線Aの中点とロボット本体の座標を結んだ線Bを表示する。

線Aが平面Z上にあるように、かつ、線Bが平面Zに対して垂直になるように、ロボットの座標系を回転と平行移動させる。

**仕様**

1. `World`クラス
    - 床のZ座標が0とする。
    - `collision_detection(position)`メソッドで、与えられたポジションが床(Z<0)に接触しているかどうかを判断する。
    - Robot本体に取り付けられた脚それぞれで、番号が最も大きな頂点を、床に接する頂点と考える。二本の脚が地面に接するようにRobotクラスの座標系を回転させ、ロボット全体の角度を決定する

2. `Robot`クラス
    - ロボット本体(赤点)と2つの脚(青点)を持つ。
    - 初期化時にロボット本体と脚の位置を設定する。
    - `move(delta_position)`メソッドで、ロボット本体を指定された位置だけ移動させる。ただし、床との衝突がない場合のみ。
    - `update_legs()`メソッドで、ロボット本体の移動に応じて脚の位置を更新する。
    - `visualize_robot_position()`メソッドで、ロボット本体と脚の位置を3Dグラフ上に表示する。また、Z=0の床も表示する。

3. `Leg`クラス
    - 脚はロボット本体に取り付けられ、相対位置オフセットが与えられる。
    - 脚は2つの頂点(vertex1とvertex2)からなるリンクを持っており、vertex1はロボット本体に取り付けられた位置で、vertex2はvertex1からZ軸方向に-1ずれた位置となる。
    - ロボット本体が移動すると、脚のリンクもそれに従って更新される。

-----
プロンプトで以下の検討を依頼する

座標変換の設計について、検討したいです。
以下に述べる考察を整理して、わかりやすくしてください。
その後、この考え方を実現するのに最適な方法やライブラリを教えてください。

考察
各クラスはローカルな座標と、上位の座標系に対し、平行移動や回転している状態を表現する行列を持ちます。
World->Robot->Legの順で座標系の変換が伝播するため、下位のクラスは上位のクラスの行列の影響を受けます。
また、自分のクラスに属する頂点やリンクもこの行列の影響を受けます。
つまり、私のやりたいことを検討すると、上位のクラスの姿勢を継承していって決まってしまうグローバルな座標系と、自分自身で決定できるローカルな座標系の2つを持ち、上位から与えられtグローバルな座標系に、自分のローカルな座標系の変換をかけて、下位に渡していく必要があると考えます。

---
座標変換に関する考察を整理します。

1. 各クラスは、ローカル座標系と上位の座標系に対して平行移動や回転を表現する行列を持ちます。
2. 座標系の変換は、`World -> Robot -> Leg` の順で伝播し、下位のクラスは上位のクラスの行列の影響を受けます。
3. クラス内の頂点やリンクも、それぞれ所属するクラスの変換行列の影響を受けます。
4. したがって、各クラスは、上位のクラスから継承されるグローバル座標系と、自分自身で管理するローカル座標系の2つを持ちます。
5. クラスは、上位から渡されたグローバル座標系に自分のローカル座標系の変換を適用し、次の下位クラスに伝播させていく必要があります。

この考え方を実現するためには、座標変換および行列操作を行うライブラリが適切です。Pythonでは、以下の2つのライブラリが座標変換の実現に適しています。

1. **NumPy**: 数学的な関数や高速な行列操作をサポートするライブラリで、Pythonの科学計算やデータ処理で広く使われています。特に、`numpy.dot()` を使用して行列の積を計算したり、`numpy.linalg.inv()` を使用して逆行列を計算することができます。

2. **SciPy**: もうすでにコード内でインポートされている `scipy.spatial.transform` モジュールには、オブジェクトや行列に回転を適用するための便利な機能が提供されています。例えば、`Rotation` クラスを使用して回転の表現や変換を簡単に行うことができます。

これらのライブラリを使用して、上記の考察に基づく座標変換設計を実現することができます。既存のコードでは、NumPyとSciPyの一部機能がすでに使用されており、それらと組み合わせて必要な座標変換設計を行うことが可能です。

---

座標系の計算を丸投げすると、わけがわからなくなるのでやめた方がよさそう。

---

pythonでシリアルサーボとの通信プログラムを実装したいです。
WindowsのPCからUSBでFEETECH FE-URT1-COO1シリアルバスサーボ用USBプログラマ基板に接続し、LX-224を複数制御します。

どのようなソフトウェア構成が妥当か、検討して教えてください。



